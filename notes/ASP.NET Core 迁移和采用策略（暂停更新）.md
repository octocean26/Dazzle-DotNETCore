# ASP.NET Core 迁移和采用策略（暂停更新，未修复）

ASP.NET Core不是ASP.NET 4.x的最新版本。尽管名称不幸（但是有意选择），但它是一个全新的框架，尽管受到当前ASP.NET，特别是ASP.NET MVC框架的深刻启发。总的来说，我们不会说实话，因为ASP.NET核心是ASP.NET，就像今天重写它一样。与传统的ASP.NET相比，它更加模块化，内存占用更少，并且可以针对多个硬件/软件平台。例如，新的ASP.NET Core应用程序现在也可以在各种Linux和Mac OS平台上本机运行。ASP.NET Core不仅仅是一个新的面向Web的框架。它是一个Web框架，但它仍然需要一个底层的通用框架。它是底层框架 - .NET Core框架 - 最终提供跨平台功能。关于开发影响，ASP.NET Core和.NET Core是一个与ASP.NET和2002年发布的.NET Framework相同数量级的组合平台。幸运的是，新平台与当前之间的差距要小得多今天比2002年回来了。

无论如何，ASP.NET Core改变了在Microsoft堆栈上开发Web应用程序的方式。对整个团队来说，刷新一些技能是不可避免的。因此，编写ASP.NET Core平台是一个需要考虑的成本，超出了构建应用程序的预算。如果您是公司内部的决策者，如果您是愿意提供帮助的顾问，如何销售它，那么您如何处理ASP.NET Core？

在本章中，我们将尝试确定新框架的承诺，以实现真正的好处。



## 寻找商业价值

说实话。没有客户愿意为改变适用于其他应用程序的应用程序付费。与此同时，没有任何软件在生产过程中仍然是静态的，不可变的。业务变化等应用程序理想情况下应随之改变;有时，这意味着激进的重写。当一个全新的商业机会出现或有吸引力的新技术首次亮相时，重大改写是一种选择。

ASP.NET Core不会创造新的商机，但它是一个非常有趣的技术。确定它有多么有趣和有益，是个问题。 ASP.NET Core与增强现有应用程序以应对新的业务需求几乎没有关系。但是，当新的业务需求出现时，升级到ASP.NET Core是一个需要认真考虑的选择。

### 寻找好处

总而言之，我相信围绕ASP.NET Core有很多不必要的炒作。正如我所看到的那样，炒作相当于纯粹的热情，却没有明确解释交换机的商业利益。然而，当谈到做出这个决定时，找到一个好的商业理由来放弃一个相对较新的系统，一个全新的系统与旧系统相同的工作变得非常棘手。

一个非常强调的好处是ASP.NET Core使您的代码能够在多个平台上运行。这是事实，但前提是您重写所有代码以解决.NET Core框架问题。大多数文献还强调其他好处，如性能改进，代码模块化和开源代码。还强调了诸如全新的中间件和通过框架广泛使用依赖注入等真正令人讨厌的观点。

虽然我不是说这些根本不是好处，但它们对业务的真正影响仅取决于业务本身。当您没有遇到响应缓慢时，支付更快的应用程序是没有意义的。当你有一个既定的业务并且没有任何期望以指数方式增长时，支付扩大规模的潜力也是毫无意义的。

微软为一家外包大部分开发项目的公司开源ASP.NET代码的价值是什么？列表可以继续。让我们试着用更具批判性的眼光来看待ASP.NET Core最普及的好处。

### 多平台支持

.NET Core框架是.NET Framework的完全重写，专门为在Windows之外的几个不同平台上编译而创建。因此，面向.NET Core框架的ASP.NET Core应用程序也可以托管在各种Linux服务器平台上。确切地说，.NET Core框架也可以在Mac OS上运行，但出于托管的目的，它目前没有任何区别，因为没有托管平台基于Mac OS。但与此同时，让.NET Core框架也针对Mac OS至少使开发人员能够在其Mac笔记本电脑上本地编译其ASP.NET Core应用程序。

在我看来，ASP.NET Core应用程序的跨平台特性是它具有的最相关的商业价值。有些人可能会争辩说，因为它仍然是一个Web应用程序，它已经可以从任何平台和操作系统到达。然而，真正的观点是托管不仅仅是触及范围。有许多公司因为运行Windows Server所必需的许可证或仅限于使用Linux等开放平台而不考虑ASP.NET。 （这有时会发生在一些公共政府机构中，因为人们错误地认为采用开放式平台真的是“像啤酒一样免费”。）此外，Windows托管仍然比Linux托管更昂贵。这不是一个巨大的差异，差异可能正在缩小，但Linux往往会更便宜，这使得ASP.NET值得考虑。最后，跨平台的ASP.NET对公司是有益的，因为它使他们能够在更便宜的Linux机器上节省一些运行应用程序的额外资金，至少用于（集成）测试目的。此外，Linux托管生态系统比Windows更大（参见Mesos，Marathon和Aurora），并且不会将您锁定到单个供应商。

### 提高性能

如果一个完全重写的框架并不比15年前的框架快得多，那真是令人惊讶。因此，无论如何，ASP.NET Core比经典ASP.NET更快。让我们先看看为什么先看看一些快速的客观数字

首先，ASP.NET Core管道是异步的，这可以保证最少数量的池化线程在任何时候都很忙。此外，管道经过重新设计，极其模块化。最后，Kestrel在调度请求方面非常快。接下来，每个请求的内存占用量的全部内容在ASP.NET Core中大约小五倍。

内存占用点值得进一步关注。如第14章所述，HTTP运行时管道已完全重构。在ASP.NET Core之前，ASP.NET应用程序请求是在20年前设计的同一个运行时中处理的，现在已成为ASP.NET Web Forms。旧管道的跳动核心是臭名昭着的system.web组装。许多人认为system.web程序集是经典ASP.NET应用程序性能不佳的罪魁祸首，尽管我只是部分订阅了这个视图。 system.web程序集是为ASP.NET Web Forms量身定制的，它做得非常精美，可以存活20年。当Microsoft引入ASP.NET MVC时，它选择仅向同一运行时添加必要的运行时扩展。由于这个设计决定，ASP.NET MVC从未拥有它应得的精简和量身定制的运行时。通过设计，它被赋予了更大的运行时间，总结了两种截然不同的应用程序模型（Web Forms和MVC）的功能。

更糟糕的是，在推出ASP.NET MVC几年后，微软也推出了Web API。 Web API是从头开始设计的，并为处理请求提供了自己的运行时，但它依赖于ASP.NET运行时进行托管。如图16-1所示，任何使用ASP.NET MVC和Web API的应用程序的内存占用量可能是其实际需要的三倍。这不是臭名昭着的system.web汇编造成的。

![16_1](assets/16_1.jpg)

ASP.NET Core性能改进的另一个方面是它的模块化。整个框架以NuGet包的形式发布，它允许您挑选您真正需要的功能。在经典的ASP.NET中，运行时只能部分自定义，因为某些HTTP模块可能被禁用，但整个请求处理管道在很大程度上是硬编码的。在仅运行ASP.NET的情况下，您的代码可能比ASP.NET Core更快地运行。

至于支持改进功能的数字，您可能需要查看https://github.com/aspnet/benchmarks上发布的基准测试。那里的数字可能无法绝对衡量您的应用程序的速度。它仍然是一个基准，因此对于实际应用来说，数字实际上要小得多。但是，ASP.NET和ASP.NET Core的基准测试之间的比例可能会相同。而且这个比例表明ASP.NET Core在一个单位时间内可以提供的请求数量快了大约五倍。但是，请注意，每个应用程序在处理的实际请求数量方面都有所不同。

最后，关于性能的一个鲜为人知的观点是应用程序微调的实际功能。通过简单地使用AddMvcCore交换AddMvc，您几乎可以将请求的速度提高一倍，至少对于处理的初始部分而言。一项实验表明，使用核心配置，使用ASP.NET Core服务100万个请求的时间从超过两秒减少到1.2秒。有关更多详细信息，请参阅http://bit.ly/2wuvhDl。

### 改善部署体验

Classic ASP.NET支持ASP.NET Core Marketing定义为依赖于框架的部署体验。换句话说，应用程序只附带自己的二进制文件，这意味着必须在服务器上安装必要的框架。多个应用程序可以共享相同的框架，但某些应用程序可能需要同一框架的不同版本。在这种情况下，必须安装两个框架，并且可能会出现细微的问题。这是臭名昭着的“DLL地狱”，或者与它非常相似的东西。

ASP.NET Core带来了额外的部署体验 - 自包含部署。在这种情况下，应用程序附带自己的二进制文件以及整个框架。应用程序占用自己的空间，无论在服务器上安装什么，都可以完全隔离。该解决方案保证了无与伦比的隔离，代价是将必要的磁盘空间增加一个数量级，通常从几兆字节增长到几十兆字节。

如前一章所述，您可以在各种Web服务器上托管ASP.NET Core应用程序，尤其是Linux上的IIS和Apache。但是，部署体验并不仅限于我们在第15章中已经介绍过的选项。虽然不常见，但您仍然可以在完全自定义的最小Web服务器中托管ASP.NET应用程序，这可能会使开源Web服务器项目失效。至少，这样的Web服务器必须实现IHttpRequestFeature和IHttpResponseFeature接口。起点可以在https://github.com/Bobris/Nowin找到。

注意如果您使用的是Windows，并且ASP.NET Core应用程序以完整的.NET Framework为目标，您甚至可以将其作为Windows服务托管。一个例子是https://docs.microsoft.com/en-us/aspnet/core/hosting/windows-service。

### 改善发展经验

ASP.NET核心编程经验简直太棒了。重新设计的框架非常好并且架构得很好。它可能有点过于设计，但所有当前最好的ASP.NET编程实践都已合并。至少几年你几乎找不到更好的框架。

此外，您不再局限于Visual Studio作为编程环境。您现在可以使用Visual Studio代码开发您的应用程序，与Visual Studio甚至是JetBrains的Rider相比，它是免费且轻量级的。 Visual Studio Code就像Rider一样，也可以在不同的平台上使用。

从纯粹的编程角度来看，Microsoft统一了MVC和Web API控制器模型并添加了本机依赖注入。此外，中间件的模块化是极端的，你真的有前所未有的机会只编写你需要的代码而没有额外的代码。

### 开源

可以在https://github.com/aspnet找到ASP.NET Core的完整源代码。从那里，您可以在许多存储库中导航，以查找构成框架的各种包以及文档和示例。所有项目都经常被数百名Microsoft贡献者和社区成员更新。开源运动是微软对ASP.NET Core承诺的强烈声明。如果您对框架有疑问，请考虑自2015年2月以来没有新版本的经典ASP.NET MVC。当然，经典的ASP.NET MVC已经完成了很多工作，而且还没有太多要添加的内容，但是这表明整个开发工作已转移到ASP.NET Core。因此，最终，拥抱ASP.NET核心纯属时间问题。从短期来看，这也是一个在其中找到具体商业价值的问题。

### 偏爱微服务架构

微服务架构如今非常流行，因为它很好地结合了面向服务架构的核心思想，而没有SOA原则的官僚作风。从本质上讲，微服务是一种可独立部署的软件应用程序，它是自治的，具有明确定义的边界。微服务可以用任何语言编写，并使用任何技术，因为它是独立开发和部署的，它通过标准通道进行通信，无论是HTTP / TCP，消息队列，还是共享数据库或文件。

ASP.NET Core因其轻量级的特性，速度和灵活性而适用于实现微服务。此外，对Docker的支持有助于使ASP.NET Core在微服务方面更加有趣。

### 布朗菲尔德发展

现在应该很清楚，采用ASP.NET Core不是升级到已经使用的下一版本的框架或产品。例如，升级到ASP.NET与从SQL Server 2014升级到SQL Server 2016不同。升级SQL时，所有表，视图和过程都将保持完整功能，并且您还具有其他功能（例如本机） JSON和版本化表格，以便在您方便的时候使用。升级到ASP.NET Core没有提供这样平滑的过渡。至少，您花钱重写与以前相同的系统，更不用说培训开发人员的成本 - 任何开发人员 - 为此以及随后的，虽然是暂时的，生产力下降。如果使用CI，还需要考虑使连续集成（CI）管道适应.NET Core CLI工具的成本。您在新框架上拥有与之前相同的系统，其价格取决于向团队成员学习的技能和态度。

一个简单的考虑因素是没有客户会合理地支付更换与另一个有效系统一起工作的系统。这个想法使我们直接进入棕色地带的发展。

在软件中，术语棕色地带开发表示在开发新系统时考虑现有系统的情况。换句话说，棕色地带开发是在现有系统和技术的约束下开发新软件。在棕色字段开发场景中采用像ASP.NET Core这样的破坏性框架之前，您可能需要非常谨慎。

要在棕地场景中添加ASP.NET Core，您必须首先转向更分散的体系结构，其中系统的整体行为是由多个独立组件（微服务）的组合产生的。在这种情况下，您可以认真考虑使用刚插入的新组件替换一个或多个组件，并使用新的，甚至是破坏性的框架。总而言之，在破坏性框架变更面前，您必须决定什么是遗产，什么不遗产。您需要考虑更换非传统组件。关于将.NET体系结构发展为微服务的主题，请参阅https://aka.ms/microservicesebook上的电子书。

最后，使用ASP.NET Core进行棕色地带开发是现实的，但通常非常昂贵。余额全部来自它所提供的具体商业价值。这只能根据具体情况和业务情况来看待。最后，考虑一下如果你使用棕色地带开发，唯一的事实是你被迫选择遗产和什么不是，这是减少技术债务的一个步骤。

注意为了保留在ASP.NET空间中，请注意组件供应商仍然将大部分收入用于ASP.NET Web Forms产品，因为公司专注于自己的业务并将软件真正用作服务。只有在业务场景发生变化时（例如，由于可扩展性问题或抓住新机会），公司才会合理地考虑深度重构或重写。可伸缩性是最滥用的词之一，尤其是关于ASP.NET Core。我不认为那里的每家公司都有可扩展性问题。我宁愿强调，默认情况下，良好的代码可以很好地扩展。因此，当您意识到存在可伸缩性问题时，通常是因为您的代码质量很差。

### 绿地开发

绿地开发与棕地开发相反，它发生在新的软件系统开发时没有任何限制。作为一名架构师，您可以自由地做出最佳决策而不会妥协。在这种情况下，确定是否采用ASP.NET Core的观点变成了纯粹的技术问题。

让我们看一下采用ASP.NET Core给ASP.NET开发人员带来的技术挑战。没有过去ASP.NET经验的开发人员可能会发现这个delta的概要与之前版本的框架没什么关系。然而，在我们到达那里之前，重要的是要看看.NET标准的故事。

### .NET标准规范

.NET标准规范试图解决在同一应用程序（移动，Web和桌面）的多个版本之间共享.NET代码的问题。多个应用程序可能共享同一个类库，每个应用程序都针对特定版本的.NET Framework，并且无法保证类库只调用框架支持的函数。

.NET标准提供了一种很好的方法来命名和版本.NET Framework的特定快照。因此，.NET标准的每个版本都定义了.NET的任何实现必须提供的API才能符合要求。换一种方式;一旦类库符合.NET标准的版本，任何针对与标准兼容的.NET Framework版本的应用程序都可以安全地使用它。

.NET标准的最新版本是.NET Standard 2.0，它与.NET Core 2.0密切相关。这应该是任何涉及ASP.NET Core的新绿地开发的最低要求。 .NET Standard 2.0包含比以前任何版本更多的类（甚至ADO.NET类都返回）。根据微软的说法，NuGet上超过70％的库只使用.NET Standard 2.0的API部分。

这是针对ASP.NET Core 2.0的ASP.NET Core应用程序的CSPROJ文件中的框架签名。

```xml
<PropertyGroup>
    <TargetFramework>netcoreapp2.0</TargetFramework>
</PropertyGroup>
```

这是.NET Standard类库的签名。

```xml
<PropertyGroup>
  <TargetFramework>netstandard2.0</TargetFramework>
</PropertyGroup>
```

请注意，要创建.NET Standard类库，必须从与常规.NET Core应用程序不同的节点中选择Visual Studio中的特定模板。 （见图16-2。）

![16_2](assets/16_2.jpg)

### ASP.NET开发人员的不同之处

在ASP.NET Core中，一些编程杂务需要与以前版本的ASP.NET不同的方法，并且熟悉一组新的API。表16-1列出了差异。

表16-1 ASP.NET Core中的编程任务不同

| Task                        | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| Starting up the application | global.asax文件已经消失，因此它是web.config文件。应用程序的初始配置发生在启动文件中，还包括隐藏在IIS和ASP.NET设置的折叠中的任务（设置Web主机）。该应用程序由一组正确配置的服务组成。此外，该框架引入了托管环境的概念，即携带有关当前运行时环境的信息的对象。 |
| Serving static files        | ASP.NET Core应用程序直接提供静态文件，而无需Web服务器的中介。必须显式配置此行为，但配置非常灵活，您可以从任何路径和数据源提供静态文件。 |
| Passing dependencies around | 大多数经典ASP.NET应用程序使用选择的IoC提供程序来传递依赖关系。 ASP.NET Core自带的DI子系统无法取消激活，但它可以替换为已移植到.NET Core的兼容IoC，并且还具有ASP.NET Core DI系统的特殊连接器。 |
| Reading configuration data  | ASP.Net Core不再包含web.config文件以包含基本应用程序设置。配置数据显示为由各种数据提供程序（JSON，文本文件和数据库）填充的分层对象模型。配置数据通过DI传递。 |
| Authentication              | 身份验证方案现在基于声明，不再严格基于cookie。身份和主体等概念仍然存在，但API虽然在概念上兼容，但却有所不同。 |
| Authorization               | 授权API与传统ASP.NET一样，但ASP.NET Core以授权策略的形式提供有价值的扩展。您可能需要认真考虑政策。 |

如您所见，绝大多数更改都适用于控制流到达控制器类层之前。控制器基本相同，因此它适用于视图。还有一些额外的功能和改进，但是围绕控制器和视图的99％的代码通常在ASP.NET Core中保持不变或只有很小的修复。所以这是你的编程技巧。

### 我应该使用ASP.NET Core吗？

这是关键问题：对于绿地开发，ASP.NET Core 2.x是一个可行的选择吗？

我目前的答案是肯定的。我对该框架早期测试日以来的预测是，到2018年底，它将成为一个值得考虑的重要选择。2015年底的一个轻松的预测，现在似乎已经通过整个行业的事实和情绪得到了很好的解决。甚至有点超出预期。除了Fanboys和营销人员之外，该框架非常好，但在实际业务和物理预算方面，这还不够。

对于数据访问，如果您发现最新的EF Core存在问题，那么您还有很多其他选项，如我们在第9章中讨论的那样。一个好的替代方案是使用微O / RM框架。至于SignalR，它自2.1版以来一直是ASP.NET Core系列的官方部分。

有什么遗漏？在微软方面，我想念OData（没有关于未来支持的传言），我希望看到一个支持SQL Server 2016及更新版系统版本表的EF Core。但是，您必须查看自己的第三方依赖项列表，以查看哪些尚未符合.NET Core，可能会危及采用。



## 概述一个战略

假设你想要一个现有的应用程序并为ASP.NET Core重写它。该场景是一个业务线应用程序，需要刷新并可能需要新架构。换句话说，该场景是关于重写相同的业务线应用程序，以使其满足相同的业务需求以及更多。

我不会将其归类为普通绿地开发或棕地开发。这是我们称之为“黄色地带”发展的中间方式。从本质上讲，它是一个没有架构限制的新应用程序，但我们正在观察尽可能保留当前生产系统的代码和专业知识的非功能性要求。

### 处理缺失的依赖关系

当你开始一个大的重写项目时，架构支柱可能会有所不同，但是为了用实际代码充实它，你可能希望尽可能地重用旧代码以节省开发时间并保留一些投资。这是合理的，只要它值得花费。

说到这一点，您可能会面临以下任何一种情况。

- 您使用一些尚未移植到.NET Core的NuGet包。
- 您使用的是您无法完全控制但不适用于.NET Core的自定义DLL。
- 您有一些代码层，具体取决于一些过时的Microsoft框架，包括ASP.NET Web窗体，实体框架6，ASP.NET SignalR，OData和Windows Foundation Services。
- 您有部分纯C＃代码使用不再支持的API调用。

对于任何这些问题，您有两种可能的路径：重用/调整源代码或在相同的可观察行为下完全重写源代码。在本章的其余部分，我们将开发一些可选策略来重用/调整现有代码。不过，第一个好的步骤是分析你拥有的东西。输入.NET Portability Analyzer工具。

### .NET可移植性分析器

.NET可移植性分析器是您从Visual Studio市场中获取的Visual Studio扩展。 （请参阅https://marketplace.visualstudio.com。）该工具在输入（甚至整个当前解决方案路径）中获取程序集名称，并以Excel文件的形式生成报告。 （见图16-3。）

![16_3](assets/16_3.jpg)

该报告让您了解使代码在.NET Core上成功运行所需的工作量。但确切地说，该工具不仅适用于.NET Core，而且可以针对各种目标进行配置，包括.NET Framework和.NET Standard规范的多个版本。 （见图16-4。）

![16_4](assets/16_4.jpg)

该工具不仅显示了有效代码的百分比，而且还列出了错误的内容，在某些情况下，它甚至建议执行更改。

通常，.NET Core团队遵循两个关键准则。首先，它们只包括大多数开发人员真正使用的类。其次，对于每个必要的功能，他们只提供了一个实现。例如，在完整的.NET Framework中，您至少有三个不同的类来放置HTTP调用：WebClient，HttpWebRequest和HttpClient。只有最后一个在.NET Core中可用。因此，任何使用WebClient的程序集都会降低分析器报告的百分比，尽管修复它几乎是直截了当的。通常，.NET Analyzer报告的兼容级别优于70％，是一个非常好的响应。

注意.NET可移植性分析器也可用作控制台应用程序。您可以访问https://github.com/Microsoft/dotnet-apiport。

### Windows兼容包

Windows兼容包（WCP）是一个NuGet包，可以访问.NET Core 2.0中未包含的20,000多个API。这些功能中至少有一半是仅限Windows的功能，并涉及加密，I / O端口，注册表和一些低级诊断等领域。要检查代码当前是否在Windows平台上运行，然后查看呼叫是否安全，您可以执行以下操作。

```c#
if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
{
    // Call some Windows-only function added with the WCP
    ...
}
```

此外，您还可以在WCP中找到一些新的API，这些API不在.NET Core 2.0中，并且享有跨平台实现。在此列表中，您可以找到System.Drawing，CodeDom API和内存缓存。

### 推迟跨平台挑战

可移植性分析器是您可能希望运行以测量移植工作量的工具，或者至少粗略估计其所需的工作量。但是，分析器的效果仅对您直接控制的代码组件有意义。如果您现有的应用程序依赖于外部依赖项，那么您在源代码级别上所做的工作就不多了。常见的情况是依赖于第三方NuGet包或普通类库DLL以及某些Microsoft框架的依赖性，这些框架由于各种原因在.NET Core中不可用。表16-2列出了.NET Core中目前尚不可用的最常见和最流行的.NET框架，至少在其原始形式中。

表16-2 .NET Core中不直接支持的常用Microsoft框架

| Framework                        | 最先进的                                                     |
| -------------------------------- | ------------------------------------------------------------ |
| Entity Framework 6.x and older   | 由Entity Framework Core 2.0和更新版本替换。                  |
| ASP.NET SignalR                  | 由ASP.NET Signal Core取代                                    |
| OData extensions for Web API     | 没有计划                                                     |
| Windows Communication Foundation | ASP.NET Core应用程序可以通过其他专用客户端库（https://github.com/dotnet/wcf）使用现有WCF服务，但不支持公开WCF服务。目前正在考虑此扩展。 |
| Windows Workflow Foundation      | 没有计划                                                     |

如果保持对某些框架或库的依赖对您来说至关重要，那么您前面只有两条路线。一个是保持您正在使用的当前非.NET核心平台的良好工作。另一个是将前端迁移到ASP.NET Core，但推迟了跨平台的挑战。 （见图16-5。）

在创建ASP.NET Core项目时，您可以选择以.NET Core框架或完整的.NET Framework为目标。通过选择后者，您可以完整地保留现有代码，至少保留处理依赖关系的部分。实际上，您仍然必须重写应用程序的启动，删除global.asax，web.config和其他经典ASP.NET实践。

如果针对.NET Core框架，ASP.NET Core会释放其真正的强大功能。但是，一般建议仅在必要时定位完整的.NET Framework。但是，与此同时，如果需要定位完整的.NET Framework，即使不将代码移植到ASP.NET Core，也可以继续前进。

![16_5](assets/16_5.jpg)


### 迈向微服务架构

为了保留现有的关键代码而针对完整的.NET Framework是一种选择，但它是一种选项，倾向于在生成的应用程序中维护单片结构。让我们深入研究一个非常具体的场景：保留对EF6数据访问代码的投资。

#### EF6和有界上下文

实体框架核心和实体框架6看起来非常相似，但它们在封面上却截然不同。最相关的事实是，无论如何，您不必重新学习所有内容，因为这两个框架共享相同的目标。就个人而言，因为我总是使用EF6中非常有限的一组函数，只要我将EF6代码放到EF Core项目中，它总是很快就能很好地工作，只需要很少的调整。然而，我正在谈论Code First代码，没有延迟加载，没有分组，没有脚手架和迁移，也没有事务 - 只是简单的查询和更新。

EF Core正在稳步发展，但这是一个很大的重写，正如你在职业生涯中可能已经经历的那样，任何重大改写都需要花费大量时间。从EF Core 2.0开始，除非您有令人信服的理由尝试更改，否则团队仍不建议将EF6应用程序移至EF Core。建议的方法是从头开始使用EF Core重写数据访问层，每当遇到不存在或工作方式不同的功能时，都会找到解决方法。这种非常基本的CRUD代码的方法今天可以很好地工作。您可以在http://github.com/aspnet/EntityFrameworkCore/wiki/Roadmap上阅读EF Core的当前路线图。我特别推荐Backlog区域中的Critical O / RM功能部分。

总的来说，当应用程序移植到ASP.NET Core时，您应该如何处理重要的EF6数据访问层？这是有限的上下文派上用场的地方。图16-6显示了第一种方法。您将应用程序保留为整体，并且只是推迟跨平台挑战并选择完整的.NET Framework作为目标。

![16_6](assets/16_6.jpg)

或者，您可能希望将EF6数据访问层与独立API隔离，并将其与主应用程序分离，主应用程序可以为ASP.NET Core和.NET Core框架开发。在这样做时，您还可以使用EF Core和EF6代码对数据访问层的功能进行分区。 （见图16-7。）

![16_7](assets/16_7.jpg)

这种模式最终会导致微服务架构，可以根据需要随时使用，也可以在容器技术中找到匹配。

#### 关于容器的更多信息

在将应用程序划分为更小的部分时，您就开始使用微服务架构。如果业界对微服务一词的共享定义达成一致意见，那么定义与以下内容不会有太大不同：微服务是一种可独立运行的应用程序，它可以自主运行并使用自己的技术，语言和基础设施。可独立部署本身就意味着可以部署微服务而不会影响应用程序的其余部分。部署可以通过多种方式进行，包括通过容器。

如今，容器通常在微服务架构中使用。通常，无论其体系结构和技术如何，您都可以容纳任何Web应用程序或Web API。所有技术都与容器的眼睛相同，但不可避免地，有些技术比其他技术更平等。例如，您可以容纳任何.NET Framework应用程序，但这只能在Windows容器上实现。相反，.NET Core应用程序可以在Windows和Linux中进行容器化。此外，.NET Core容器映像的大小远小于非.NET Core应用程序的相同映像。最后，由于.NET Core应用程序是跨平台的，因此可以将映像删除到Linux容器以及Windows容器。



## 概要

没有人应该采用ASP.NET Core只是因为它是旧的熟悉的ASP.NET框架的新版本。相反，您应该在ASP.Net Core中查看是否有商业价值。 ASP.NET Core的主要价值在于其跨平台性质，具体地允许公司通过托管应用程序来节省资金 - 用于生产或测试更便宜的Linux服务器。另一个需要考虑的因素是ASP.NET Core运行时的性能得到改善，同时，框架的极端模块化为高度可扩展的应用程序提供了良好的素材。

所有这些都表示，如果您今天没有遇到性能问题并且没有明显的扩展和架构变化，那么为移植而移植绝不是一个精明的选择。